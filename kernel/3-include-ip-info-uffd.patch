From 08e1791e714a1fd11a806e173ad31560eb090d4d Mon Sep 17 00:00:00 2001
From: Anil Yelam <yelama@vmware.com>
Date: Wed, 8 Jun 2022 15:25:14 -0700
Subject: [PATCH] Send more details for each fault to userspace (ip register
 and unmasked address)

Encapsulated ip info in one of the reserved fields in uffd_msg
---
 fs/userfaultfd.c                 | 13 ++++++++++---
 include/linux/mm.h               |  2 ++
 include/uapi/linux/userfaultfd.h |  5 ++---
 mm/hugetlb.c                     |  1 +
 mm/khugepaged.c                  |  1 +
 mm/memory.c                      |  6 ++++--
 6 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c
index 894cc28142e7..69c0f7cb9b67 100644
--- a/fs/userfaultfd.c
+++ b/fs/userfaultfd.c
@@ -27,6 +27,7 @@
 #include <linux/ioctl.h>
 #include <linux/security.h>
 #include <linux/hugetlb.h>
+#include <linux/ptrace.h>
 
 int sysctl_unprivileged_userfaultfd __read_mostly;
 
@@ -190,7 +191,8 @@ static inline void msg_init(struct uffd_msg *msg)
 static inline struct uffd_msg userfault_msg(unsigned long address,
 					    unsigned int flags,
 					    unsigned long reason,
-					    unsigned int features)
+					    unsigned int features,
+						struct pt_regs* regs)
 {
 	struct uffd_msg msg;
 	msg_init(&msg);
@@ -216,6 +218,11 @@ static inline struct uffd_msg userfault_msg(unsigned long address,
 		msg.arg.pagefault.flags |= UFFD_PAGEFAULT_FLAG_WP;
 	if (features & UFFD_FEATURE_THREAD_ID)
 		msg.arg.pagefault.feat.ptid = task_pid_vnr(current);
+
+	/* writing ip register */
+	if (regs)
+		msg.ip = instruction_pointer(regs);
+
 	return msg;
 }
 
@@ -480,8 +487,8 @@ vm_fault_t handle_userfault(struct vm_fault *vmf, unsigned long reason)
 
 	init_waitqueue_func_entry(&uwq.wq, userfaultfd_wake_function);
 	uwq.wq.private = current;
-	uwq.msg = userfault_msg(vmf->address, vmf->flags, reason,
-			ctx->features);
+	uwq.msg = userfault_msg(vmf->unmasked_address, vmf->flags, reason, 
+				ctx->features, vmf->regs);
 	uwq.ctx = ctx;
 	uwq.waken = false;
 
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 5299b90a6c40..31af152a89e7 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -512,6 +512,7 @@ struct vm_fault {
 	gfp_t gfp_mask;			/* gfp mask to be used for allocations */
 	pgoff_t pgoff;			/* Logical page offset based on vma */
 	unsigned long address;		/* Faulting virtual address */
+	unsigned long unmasked_address;	/* Faulting virtual address - unmasked */
 	pmd_t *pmd;			/* Pointer to pmd entry matching
 					 * the 'address' */
 	pud_t *pud;			/* Pointer to pud entry matching
@@ -541,6 +542,7 @@ struct vm_fault {
 					 * page table to avoid allocation from
 					 * atomic context.
 					 */
+	struct pt_regs* regs;
 };
 
 /* page entry size for vm->huge_fault() */
diff --git a/include/uapi/linux/userfaultfd.h b/include/uapi/linux/userfaultfd.h
index 5f2d88212f7c..3e39b2eefcec 100644
--- a/include/uapi/linux/userfaultfd.h
+++ b/include/uapi/linux/userfaultfd.h
@@ -75,12 +75,11 @@
 				      struct uffdio_writeprotect)
 
 /* read() structure */
-struct uffd_msg {
+struct uffd_msg  {
 	__u8	event;
 
 	__u8	reserved1;
-	__u16	reserved2;
-	__u32	reserved3;
+	__u64	ip:48;
 
 	union {
 		struct {
diff --git a/mm/hugetlb.c b/mm/hugetlb.c
index cbf32d2824fd..5686144f886b 100644
--- a/mm/hugetlb.c
+++ b/mm/hugetlb.c
@@ -4284,6 +4284,7 @@ static vm_fault_t hugetlb_no_page(struct mm_struct *mm,
 				 * uninitialized fields... same as in
 				 * memory.c
 				 */
+				.regs = NULL,
 			};
 
 			/*
diff --git a/mm/khugepaged.c b/mm/khugepaged.c
index 67ab391a5373..fc0da6346c4a 100644
--- a/mm/khugepaged.c
+++ b/mm/khugepaged.c
@@ -1002,6 +1002,7 @@ static bool __collapse_huge_page_swapin(struct mm_struct *mm,
 		.flags = FAULT_FLAG_ALLOW_RETRY,
 		.pmd = pmd,
 		.pgoff = linear_page_index(vma, address),
+		.regs = NULL,
 	};
 
 	vmf.pte = pte_offset_map(pmd, address);
diff --git a/mm/memory.c b/mm/memory.c
index 7d608765932b..b1960e35a3dc 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -4432,14 +4432,16 @@ static vm_fault_t handle_pte_fault(struct vm_fault *vmf)
  * return value.  See filemap_fault() and __lock_page_or_retry().
  */
 static vm_fault_t __handle_mm_fault(struct vm_area_struct *vma,
-		unsigned long address, unsigned int flags)
+		unsigned long address, unsigned int flags, struct pt_regs* regs)
 {
 	struct vm_fault vmf = {
 		.vma = vma,
 		.address = address & PAGE_MASK,
+		.unmasked_address = address,
 		.flags = flags,
 		.pgoff = linear_page_index(vma, address),
 		.gfp_mask = __get_fault_gfp_mask(vma),
+		.regs = regs,
 	};
 	unsigned int dirty = flags & FAULT_FLAG_WRITE;
 	struct mm_struct *mm = vma->vm_mm;
@@ -4615,7 +4617,7 @@ vm_fault_t handle_mm_fault(struct vm_area_struct *vma, unsigned long address,
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma->vm_mm, vma, address, flags);
 	else
-		ret = __handle_mm_fault(vma, address, flags);
+		ret = __handle_mm_fault(vma, address, flags, regs);
 
 	if (flags & FAULT_FLAG_USER) {
 		mem_cgroup_exit_user_fault();
-- 
2.25.1

